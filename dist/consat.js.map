{"version":3,"sources":["webpack://consat/webpack/universalModuleDefinition","webpack://consat/webpack/bootstrap","webpack://consat/./node_modules/loglevel/lib/loglevel.js","webpack://consat/./node_modules/uuid/v1.js","webpack://consat/./node_modules/uuid/lib/rng-browser.js","webpack://consat/./node_modules/uuid/lib/bytesToUuid.js","webpack://consat/./src/exceptions.js","webpack://consat/./src/cspsolver.js","webpack://consat/./src/variable.js","webpack://consat/./src/constraint.js","webpack://consat/./src/assignment.js","webpack://consat/./src/solution.js","webpack://consat/./src/backtrackingsolver.js","webpack://consat/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","definition","undefined","noop","undefinedType","logMethods","bindMethod","obj","methodName","method","Function","e","apply","arguments","replaceLoggingMethods","level","loggerName","length","this","methodFactory","log","debug","defaultMethodFactory","console","realMethod","Logger","defaultLevel","currentLevel","self","storageKey","getPersistedLevel","storedLevel","localStorage","ignore","cookie","document","location","indexOf","encodeURIComponent","exec","slice","levels","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","toUpperCase","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","_nodeId","_clockseq","rng","bytesToUuid","_lastMSecs","_lastNSecs","options","buf","offset","b","node","clockseq","seedBytes","msecs","Date","getTime","nsecs","dt","Error","tl","tmh","getRandomValues","crypto","msCrypto","rnds8","Uint8Array","rnds","Array","Math","random","byteToHex","toString","substr","bth","join","VariableValueError","InvalidVariableError","InvalidSolutionError","CSPSolver","cspsolver_classCallCheck","constructor","_constraints","_variables","varConstraintMap","_solutions","v","getName","getId","JSON","stringify","getV2Name","getV1Name","getV1","getV2","getV1Id","getV2Id","push","initialAssignment","getAllSolutions","assignment","varList","getVarList","trace","assignedVarMap","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","err","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","getValue","relatedConstraints","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","relConst","otherVar","getValueForVarById","getTargetValues","isComplete","isConsistent","Variable","domain","id","variable_classCallCheck","uuid","getDomain","includes","Constraint","v1","v2","mappingsV1toV2","constraint_classCallCheck","mappingsV2toV1","valueInDomain","val","vId","vValue","Assignment","assignedVariableList","assignment_classCallCheck","varMap","newVar","fromVariable","variableMap","assignmentList","varId","setValue","varName","unassignedVars","hasValue","printStr","Solution","_this","solution_classCallCheck","solution_possibleConstructorReturn","solution_getPrototypeOf","BacktrackingSolver","_getPrototypeOf2","backtrackingsolver_classCallCheck","_len","params","_key","backtrackingsolver_possibleConstructorReturn","backtrackingsolver_getPrototypeOf","concat","_get","emptyAssignment","printAssignment","treeLevel","result","recursiveSolve","replacer","solution","getUnassignedVar","varDomain","updatedDomain","orderDomainValues","item","isSolution","unassignedList","getUnassignedVariables","floor","values","__webpack_exports__","cspsolver","variable","constraint","backtrackingsolver","src_assignment","src_solution"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,GAAAH,GACA,iBAAAC,QACAA,QAAA,OAAAD,IAEAD,EAAA,OAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,EAAA,GAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,GAAA,CACAC,EAAAD,EACAE,GAAA,EACAT,QAAA,IAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,EAAA,CAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,OAAAC,eAAAnB,EAAAuB,OAAAC,YAAA,CAAwDC,MAAA,WAExDP,OAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,qBClFA,IAAAC,EAAAC,GAMA,SAAA3C,EAAA4C,GACA,kBAEyBC,KAAAF,EAAA,mBAAjBD,EAMP,WAID,IAAAI,EAAA,aACAC,EAAA,YAEAC,EAAA,CACA,QACA,QACA,OACA,OACA,SAIA,SAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAAC,GACA,sBAAAC,EAAAlB,KACA,OAAAkB,EAAAlB,KAAAgB,GAEA,IACA,OAAAG,SAAAf,UAAAJ,KAAArB,KAAAuC,EAAAF,GACa,MAAAI,GAEb,kBACA,OAAAD,SAAAf,UAAAiB,YAAAH,EAAA,CAAAF,EAAAM,cA0BA,SAAAC,EAAAC,EAAAC,GAEA,QAAAjD,EAAA,EAAuBA,EAAAsC,EAAAY,OAAuBlD,IAAA,CAC9C,IAAAyC,EAAAH,EAAAtC,GACAmD,KAAAV,GAAAzC,EAAAgD,EACAZ,EACAe,KAAAC,cAAAX,EAAAO,EAAAC,GAIAE,KAAAE,IAAAF,KAAAG,MAgBA,SAAAC,EAAAd,EAAAO,EAAAC,GAEA,OA9CA,SAAAR,GACA,UAAAA,IACAA,EAAA,OAGA,cAAAe,UAAAnB,SAESF,IAAAqB,QAAAf,GACTF,EAAAiB,QAAAf,QACSN,IAAAqB,QAAAH,IACTd,EAAAiB,QAAA,OAEApB,GAkCAqB,CAAAhB,IAbA,SAAAA,EAAAO,EAAAC,GACA,yBACAO,UAAAnB,IACAU,EAAA5C,KAAAgD,KAAAH,EAAAC,GACAE,KAAAV,GAAAI,MAAAM,KAAAL,cAUAD,MAAAM,KAAAL,WAGA,SAAAY,EAAAnD,EAAAoD,EAAApE,GACA,IACAqE,EADAC,EAAAV,KAEAW,EAAA,WAuBA,SAAAC,IACA,IAAAC,EAEA,UAAApE,SAAAyC,EAAA,CAEA,IACA2B,EAAApE,OAAAqE,aAAAH,GACW,MAAAI,IAGX,UAAAF,IAAA3B,EACA,IACA,IAAA8B,EAAAvE,OAAAwE,SAAAD,OACAE,EAAAF,EAAAG,QACAC,mBAAAT,GAAA,MACA,IAAAO,IACAL,EAAA,WAA0CQ,KAAAL,EAAAM,MAAAJ,IAAA,IAE3B,MAAAH,IAQf,YAJA/B,IAAA0B,EAAAa,OAAAV,KACAA,OAAA7B,GAGA6B,GAhDAzD,IACAuD,GAAA,IAAAvD,GAwDAsD,EAAAtD,OAEAsD,EAAAa,OAAA,CAAqBC,MAAA,EAAAC,MAAA,EAAAC,KAAA,EAAAC,KAAA,EACrBC,MAAA,EAAAC,OAAA,GAEAnB,EAAAT,cAAA7D,GAAAgE,EAEAM,EAAAoB,SAAA,WACA,OAAArB,GAGAC,EAAAqB,SAAA,SAAAlC,EAAAmC,GAIA,GAHA,iBAAAnC,QAAAb,IAAA0B,EAAAa,OAAA1B,EAAAoC,iBACApC,EAAAa,EAAAa,OAAA1B,EAAAoC,kBAEA,iBAAApC,MAAA,GAAAA,GAAAa,EAAAa,OAAAM,QAUA,kDAAAhC,EAJA,GALAY,EAAAZ,GACA,IAAAmC,GAtEA,SAAAE,GACA,IAAAC,GAAAhD,EAAA+C,IAAA,UAAAD,cAEA,UAAAxF,SAAAyC,EAAA,OAGA,IAEA,YADAzC,OAAAqE,aAAAH,GAAAwB,GAEW,MAAApB,IAGX,IACAtE,OAAAwE,SAAAD,OACAI,mBAAAT,GAAA,IAAAwB,EAAA,IACW,MAAApB,KAwDXqB,CAAAvC,GAEAD,EAAA5C,KAAA0D,EAAAb,EAAAzC,UACAiD,UAAAnB,GAAAW,EAAAa,EAAAa,OAAAM,OACA,0CAOAnB,EAAA2B,gBAAA,SAAAxC,GACAe,KACAF,EAAAqB,SAAAlC,GAAA,IAIAa,EAAA4B,UAAA,SAAAN,GACAtB,EAAAqB,SAAArB,EAAAa,OAAAC,MAAAQ,IAGAtB,EAAA6B,WAAA,SAAAP,GACAtB,EAAAqB,SAAArB,EAAAa,OAAAM,OAAAG,IAIA,IAAAQ,EAAA5B,IACA,MAAA4B,IACAA,EAAA,MAAAhC,EAAA,OAAAA,GAEAE,EAAAqB,SAAAS,GAAA,GASA,IAAAC,EAAA,IAAAlC,EAEAmC,EAAA,GACAD,EAAAE,UAAA,SAAAvF,GACA,oBAAAA,GAAA,KAAAA,EACA,UAAAwF,UAAA,kDAGA,IAAAC,EAAAH,EAAAtF,GAKA,OAJAyF,IACAA,EAAAH,EAAAtF,GAAA,IAAAmD,EACAnD,EAAAqF,EAAAX,WAAAW,EAAAxC,gBAEA4C,GAIA,IAAAC,SAAArG,SAAAyC,EAAAzC,OAAAyD,SAAAlB,EAcA,OAbAyD,EAAAM,WAAA,WAMA,cALAtG,SAAAyC,GACAzC,OAAAyD,MAAAuC,IACAhG,OAAAyD,IAAA4C,GAGAL,GAGAA,EAAAO,WAAA,WACA,OAAAN,GAGAD,IA/OyB5D,EAAA7B,KAAAX,EAAAM,EAAAN,EAAAC,GAAAuC,KAAAvC,EAAAD,QAAAyC,GAHzB,oBCNA,IAQAmE,EACAC,EATAC,EAAUxG,EAAQ,GAClByG,EAAkBzG,EAAQ,GAW1B0G,EAAA,EACAC,EAAA,EA+FAhH,EAAAD,QA5FA,SAAAkH,EAAAC,EAAAC,GACA,IAAA5G,EAAA2G,GAAAC,GAAA,EACAC,EAAAF,GAAA,GAGAG,GADAJ,KAAA,IACAI,MAAAV,EACAW,OAAA5E,IAAAuE,EAAAK,SAAAL,EAAAK,SAAAV,EAKA,SAAAS,GAAA,MAAAC,EAAA,CACA,IAAAC,EAAAV,IACA,MAAAQ,IAEAA,EAAAV,EAAA,CACA,EAAAY,EAAA,GACAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAGA,MAAAD,IAEAA,EAAAV,EAAA,OAAAW,EAAA,MAAAA,EAAA,KAQA,IAAAC,OAAA9E,IAAAuE,EAAAO,MAAAP,EAAAO,OAAA,IAAAC,MAAAC,UAIAC,OAAAjF,IAAAuE,EAAAU,MAAAV,EAAAU,MAAAX,EAAA,EAGAY,EAAAJ,EAAAT,GAAAY,EAAAX,GAAA,IAcA,GAXAY,EAAA,QAAAlF,IAAAuE,EAAAK,WACAA,IAAA,UAKAM,EAAA,GAAAJ,EAAAT,SAAArE,IAAAuE,EAAAU,QACAA,EAAA,GAIAA,GAAA,IACA,UAAAE,MAAA,mDAGAd,EAAAS,EACAR,EAAAW,EACAf,EAAAU,EAMA,IAAAQ,GAAA,gBAHAN,GAAA,cAGAG,GAAA,WACAP,EAAA7G,KAAAuH,IAAA,OACAV,EAAA7G,KAAAuH,IAAA,OACAV,EAAA7G,KAAAuH,IAAA,MACAV,EAAA7G,KAAA,IAAAuH,EAGA,IAAAC,EAAAP,EAAA,yBACAJ,EAAA7G,KAAAwH,IAAA,MACAX,EAAA7G,KAAA,IAAAwH,EAGAX,EAAA7G,KAAAwH,IAAA,SACAX,EAAA7G,KAAAwH,IAAA,OAGAX,EAAA7G,KAAA+G,IAAA,MAGAF,EAAA7G,KAAA,IAAA+G,EAGA,QAAAtF,EAAA,EAAiBA,EAAA,IAAOA,EACxBoF,EAAA7G,EAAAyB,GAAAqF,EAAArF,GAGA,OAAAkF,GAAAJ,EAAAM,mBClGA,IAAAY,EAAA,4BAAAC,OAAAD,iBAAAC,OAAAD,gBAAAjG,KAAAkG,SACA,iDAAA9H,OAAA+H,SAAAF,iBAAAE,SAAAF,gBAAAjG,KAAAmG,UAEA,GAAAF,EAAA,CAEA,IAAAG,EAAA,IAAAC,WAAA,IAEApI,EAAAD,QAAA,WAEA,OADAiI,EAAAG,GACAA,OAEC,CAKD,IAAAE,EAAA,IAAAC,MAAA,IAEAtI,EAAAD,QAAA,WACA,QAAAsB,EAAAd,EAAA,EAAsBA,EAAA,GAAQA,IAC9B,MAAAA,KAAAc,EAAA,WAAAkH,KAAAC,UACAH,EAAA9H,GAAAc,MAAA,EAAAd,IAAA,OAGA,OAAA8H,mBC1BA,IADA,IAAAI,EAAA,GACAlI,EAAA,EAAeA,EAAA,MAASA,EACxBkI,EAAAlI,MAAA,KAAAmI,SAAA,IAAAC,OAAA,GAiBA3I,EAAAD,QAdA,SAAAmH,EAAAC,GACA,IAAA5G,EAAA4G,GAAA,EACAyB,EAAAH,EAEA,OAAAG,EAAA1B,EAAA3G,MAAAqI,EAAA1B,EAAA3G,MACAqI,EAAA1B,EAAA3G,MAAAqI,EAAA1B,EAAA3G,MAAA,IACAqI,EAAA1B,EAAA3G,MAAAqI,EAAA1B,EAAA3G,MAAA,IACAqI,EAAA1B,EAAA3G,MAAAqI,EAAA1B,EAAA3G,MAAA,IACAqI,EAAA1B,EAAA3G,MAAAqI,EAAA1B,EAAA3G,MAAA,IACAqI,EAAA1B,EAAA3G,MAAAqI,EAAA1B,EAAA3G,MACAqI,EAAA1B,EAAA3G,MAAAqI,EAAA1B,EAAA3G,MACAqI,EAAA1B,EAAA3G,MAAAqI,EAAA1B,EAAA3G,OAAAsI,KAAA,k6DCdMC,4FAA2BjB,aAE3BkB,4FAA6BlB,aAE7BmB,4FAA6BnB,0LCInC,IAAMtB,EAAS3C,eACf2C,EAAOd,SAASc,EAAOtB,OAAOG,UAwJf6D,aA9IX,SAAAA,IAEI,+FAFUC,CAAAxF,KAAAuF,GACV1C,EAAO1C,MAAM,qBAAuBH,KAAKyF,aACtCzF,KAAKyF,cAAgBF,EACpB,MAAM3C,UAAU,sEAIpBC,EAAO1C,MAAM,oCACbH,KAAK0F,aAAe,GACpB1F,KAAK2F,WAAa,GAClB3F,KAAK4F,iBAAmB,GACxB5F,KAAK6F,WAAa,8DAGVC,GAKR,OAJAjD,EAAO1C,MAAM,0BAA4B2F,EAAEC,UAAY,cAC/CD,EAAEE,QAAU,iBACpBnD,EAAO1C,MAAM,mBAAqB8F,KAAKC,UAAUlG,KAAK2F,eAEnDG,EAAEE,UAAWhG,KAAK2F,cACrB3F,KAAK2F,WAAWG,EAAEE,SAAWF,GACtB,yCAGG5I,GAuBV,OAtBA2F,EAAO1C,MAAM,uCAAyCjD,EAAEiJ,YAChD,mBAAqBjJ,EAAEkJ,YAAc,yBAGxClJ,EAAEkJ,cAAepG,KAAK2F,aACvB3F,KAAK2F,WAAWzI,EAAEkJ,aAAelJ,EAAEmJ,SAElCnJ,EAAEiJ,cAAenG,KAAK2F,aACvB3F,KAAK2F,WAAWzI,EAAEiJ,aAAejJ,EAAEoJ,SAKlCpJ,EAAEqJ,YAAavG,KAAK4F,mBACrB5F,KAAK4F,iBAAiB1I,EAAEqJ,WAAa,IAEpCrJ,EAAEsJ,YAAaxG,KAAK4F,mBACrB5F,KAAK4F,iBAAiB1I,EAAEsJ,WAAa,IAEzCxG,KAAK4F,iBAAiB1I,EAAEqJ,WAAWE,KAAKvJ,GACxC8C,KAAK4F,iBAAiB1I,EAAEsJ,WAAWC,KAAKvJ,IAEjC,kCAO6C,IAAlDwJ,EAAkD/G,UAAAI,OAAA,QAAAf,IAAAW,UAAA,GAAAA,UAAA,GAA9B,KAAMgH,IAAwBhH,UAAAI,OAAA,QAAAf,IAAAW,UAAA,KAAAA,UAAA,GACpDK,KAAK2G,gBAAkBA,EACvB3G,KAAK0G,kBAAoBA,EACzB1G,KAAK6F,WAAa,wCASTe,GAET,IAAMC,EAAUD,EAAWE,aAC3BjE,EAAOkE,MAAM,wBAA0Bd,KAAKC,UAAUW,IACtD,IAAMG,EAAiB,GAJFC,GAAA,EAAAC,GAAA,EAAAC,OAAAnI,EAAA,IAKrB,QAAAoI,EAAAC,EAAeR,EAAfjJ,OAAA0J,cAAAL,GAAAG,EAAAC,EAAAE,QAAAC,MAAAP,GAAA,EAAwB,KAAdnB,EAAcsB,EAAAtJ,MAKpB,GAFA+E,EAAOkE,MAAM,uCAAyCjB,EAAEE,QACpD,gBAAkBF,EAAEC,UAAY,OAC/BD,EAAEE,UAAWhG,KAAK2F,YACnB,MAAM,IAAIN,EAAqB,qDACMS,EAAEE,QAAU,eAClCF,EAAEC,UAAY,iDAGjCiB,EAAelB,EAAEE,SAAWF,GAhBX,MAAA2B,GAAAP,GAAA,EAAAC,EAAAM,EAAA,YAAAR,GAAA,MAAAI,EAAA,QAAAA,EAAA,oBAAAH,EAAA,MAAAC,GAAA,IAAAO,GAAA,EAAAC,GAAA,EAAAC,OAAA5I,EAAA,IAkBrB,QAAA6I,EAAAC,EAAejB,EAAfjJ,OAAA0J,cAAAI,GAAAG,EAAAC,EAAAP,QAAAC,MAAAE,GAAA,EAAwB,KAAd5B,EAAc+B,EAAA/J,MAKpB,GADA+E,EAAO1C,MAAM,kBAAoB2F,EAAEiC,YAC7BjC,EAAEE,UAAWhG,KAAK4F,kBACC,OAAjBE,EAAEiC,WADV,CAMA,IAAMC,EAAqBhI,KAAK4F,iBAAiBE,EAAEE,SAX/BiC,GAAA,EAAAC,GAAA,EAAAC,OAAAnJ,EAAA,IAYpB,QAAAoJ,EAAAC,EAAsBL,EAAtBpK,OAAA0J,cAAAW,GAAAG,EAAAC,EAAAd,QAAAC,MAAAS,GAAA,EAA0C,KAAhCK,EAAgCF,EAAAtK,MAClCyK,EAAW,KAaf,GAXIA,EADDD,EAAS/B,YAAcT,EAAEE,QACbsC,EAAShC,QAGTgC,EAASjC,QAQF,OADCO,EAAW4B,mBAAmBD,EAASvC,UAO9D,KADYsC,EAASG,gBAAgB3C,EAAEE,QAASF,EAAEiC,YACzC5G,QAAQyF,EAAW4B,mBAAmBD,EAASvC,WAAa,GAQjE,OAPAnD,EAAO1C,MAAM,4EAEb0C,EAAO1C,MAAM,sBACTyG,EAAW4B,mBAAmBD,EAASvC,SACvC,qBAAsBF,EAAEE,QAAS,KACjCF,EAAEiC,WAAY,wBACdO,EAASG,gBAAgB3C,EAAEE,QAASF,EAAEiC,cACnC,OAbPlF,EAAO1C,MAAM,2EA3BD,MAAAsH,GAAAS,GAAA,EAAAC,EAAAV,EAAA,YAAAQ,GAAA,MAAAI,EAAA,QAAAA,EAAA,oBAAAH,EAAA,MAAAC,MAlBH,MAAAV,GAAAE,GAAA,EAAAC,EAAAH,EAAA,YAAAC,GAAA,MAAAI,EAAA,QAAAA,EAAA,oBAAAH,EAAA,MAAAC,GA8DrB,OAAO,qCAQAhB,GACP,OAAOA,EAAW8B,cAAgB1I,KAAK2I,aAAa/B,8NCxJ5D,IAAM/D,EAAS3C,eACf2C,EAAOd,SAASc,EAAOtB,OAAOE,WA6EfmH,aAzEX,SAAAA,EAAYxL,EAAMyL,GAAiC,IAAzB/K,EAAyB6B,UAAAI,OAAA,QAAAf,IAAAW,UAAA,GAAAA,UAAA,GAAjB,KAAMmJ,EAAWnJ,UAAAI,OAAA,QAAAf,IAAAW,UAAA,GAAAA,UAAA,GAAN,KACzC,+FAD+CoJ,CAAA/I,KAAA4I,QACnC5J,IAAT5B,QAAiC4B,IAAX6J,EACrB,MAAM,IAAIjG,UAAU,4CAExB,GAAY,KAATxF,EAAa,MAAM,IAAIwF,UAAU,mCACpC,GAAGiG,EAAOpD,cAAgBb,MACtB,MAAM,IAAIhC,UAAU,+CAExB,GAAqB,IAAlBiG,EAAO9I,OACN,MAAM,IAAI6C,UAAU,iCAIxB,GAAa,OAAV9E,IAC+B,IAA3B+K,EAAO1H,QAAQrD,GACd,MAAM,IAAIsH,EAAmB,gEAMrBpF,KAAK8I,GAAX,OAAPA,EAAuBE,MACXF,EAEf9I,KAAK5C,KAAOA,EACZ4C,KAAK6I,OAASA,EACd7I,KAAKlC,MAAQA,6DAwCGgI,GAChB,OAAO,IAAI8C,EAAS9C,EAAEC,UAAWD,EAAEmD,YAAanD,EAAEiC,WAC9CjC,EAAEE,8CAtCN,OAAOhG,KAAK8I,qCAIZ,OAAO9I,KAAK5C,yCAIZ,OAAO4C,KAAK6I,0CAIZ,OAAO7I,KAAKlC,yCAIZ,OAAsB,OAAfkC,KAAKlC,uCAGPA,GACL,IAAKkC,KAAK6I,OAAOK,SAASpL,IAAoB,OAAVA,EAChC,MAAM,IAAIsH,EAAmB,qCACdpF,KAAK8I,GAAK,iCAGzB9I,KAAKlC,MAAQA,wCAIPA,GACV,OAAOkC,KAAK6I,OAAOK,SAASpL,8MC1DpC,IAAM+E,EAAS3C,eACf2C,EAAOd,SAASc,EAAOtB,OAAOG,UAoGfyH,aAhGX,SAAAA,EAAYC,EAAIC,EAAIC,GAChB,+FADgCC,CAAAvJ,KAAAmJ,GAC7BC,EAAGrD,YAAcsD,EAAGtD,UACnB,MAAM,IAAIX,EAAmB,oEAIjC,IAAMoE,EAAiB,GAKvB,IAAI,IAAIpL,KAAOkL,EAAgB,CAC3B,IAAIF,EAAGK,cAAcrL,GAKjB,MAJA8B,QAAU,mDACU9B,EAAM,gFAElBgL,EAAGrD,UAAY,KACjB,IAAIX,EAAmB,UAAYhH,EAAM,gFAEXgL,EAAGrD,UAAY,KAR5B,IAAAkB,GAAA,EAAAC,GAAA,EAAAC,OAAAnI,EAAA,IAW3B,QAAAoI,EAAAC,EAAeiC,EAAelL,GAA9BR,OAAA0J,cAAAL,GAAAG,EAAAC,EAAAE,QAAAC,MAAAP,GAAA,EAAoC,KAA5ByC,EAA4BtC,EAAAtJ,MAC3B4L,KAAOF,IACRA,EAAeE,GAAO,IAE1BF,EAAeE,GAAKjD,KAAKrI,IAfF,MAAAqJ,GAAAP,GAAA,EAAAC,EAAAM,EAAA,YAAAR,GAAA,MAAAI,EAAA,QAAAA,EAAA,oBAAAH,EAAA,MAAAC,IAoB/BnH,KAAKoJ,GAAKA,EACVpJ,KAAKqJ,GAAKA,EACVrJ,KAAKsJ,eAAiBA,EACtBtJ,KAAKwJ,eAAiBA,yDAItB,OAAOxJ,KAAKoJ,uCAIZ,OAAOpJ,KAAKoJ,GAAGrD,4CAIf,OAAO/F,KAAKoJ,GAAGpD,wCAIf,OAAOhG,KAAKqJ,uCAIZ,OAAOrJ,KAAKqJ,GAAGtD,4CAIf,OAAO/F,KAAKqJ,GAAGrD,gDAMH2D,EAAKC,GAKjB,GAFA/G,EAAOkE,MAAM,kCAAmC4C,EAAK,iBACjDC,EAAQ,MACTD,IAAQ3J,KAAKoJ,GAAGpD,QAAS,CACxB,KAAK4D,KAAU5J,KAAKsJ,gBAIhB,MAHAzG,EAAO1C,MAAM,wBAA0ByJ,EAAS,oDACCD,EAAM,mBACjC1D,KAAKC,UAAUlG,KAAKsJ,iBACpC,IAAIlE,EAAmB,oEAGjC,OAAOpF,KAAKsJ,eAAeM,GAE1B,GAAGD,IAAQ3J,KAAKqJ,GAAGrD,QAAS,CAC7B,KAAK4D,KAAU5J,KAAKwJ,gBAIhB,MAHA3G,EAAOkE,MAAM,wBAA0B6C,EAAS,oDACKD,EAAM,mBACjC1D,KAAKC,UAAUlG,KAAKwJ,iBACxC,IAAIpE,EAAmB,oEAGjC,OAAOpF,KAAKwJ,eAAeI,GAG3B,MAAM,IAAIvE,EAAqB,8OCxG3C,IAAIxC,EAAS3C,eACb2C,EAAOd,SAASc,EAAOtB,OAAOG,UAuFfmI,aAnFX,SAAAA,EAAYC,gGAAsBC,CAAA/J,KAAA6J,GAC9B,IAAMG,EAAS,GADe/C,GAAA,EAAAC,GAAA,EAAAC,OAAAnI,EAAA,IAE9B,QAAAoI,EAAAC,EAAeyC,EAAflM,OAAA0J,cAAAL,GAAAG,EAAAC,EAAAE,QAAAC,MAAAP,GAAA,EAAqC,KAA3BnB,EAA2BsB,EAAAtJ,MACjC+E,EAAO1C,MAAM,wBACb0C,EAAO1C,MAAM,aAAe2F,EAAEC,WAC9BlD,EAAO1C,MAAM,WAAa2F,EAAEE,SAC5BnD,EAAO1C,MAAM,cAAgB2F,EAAEiC,YAC/BlF,EAAO1C,MAAM,eAAiB8F,KAAKC,UAAUJ,EAAEmD,cAC/C,IAAMgB,EAASrB,EAASsB,aAAapE,GACrCkE,EAAOC,EAAOjE,SAAWiE,GATC,MAAAxC,GAAAP,GAAA,EAAAC,EAAAM,EAAA,YAAAR,GAAA,MAAAI,EAAA,QAAAA,EAAA,oBAAAH,EAAA,MAAAC,GAW9BnH,KAAKgK,OAASA,gEA4DKG,GACnB,IAAMC,EAAiB,GACvB,IAAI,IAAMC,KAASF,EAAa,CAC5B,IAAMF,EAASrB,EAASsB,aAAaC,EAAYE,IACjDJ,EAAOK,SAAS,MAChBF,EAAe3D,KAAKwD,GAExB,OAAO,IAAIJ,EAAWO,6CA/DtB,IAAMvD,EAAU,GAChB,IAAI,IAAMzI,KAAO4B,KAAKgK,OAClBnD,EAAQJ,KAAKzG,KAAKgK,OAAO5L,IAE7B,OAAOyI,+CAGU0D,GACjB,IAAI,IAAMZ,KAAO3J,KAAKgK,OAClB,GAAGhK,KAAKgK,OAAOL,GAAK5D,YAAcwE,EAC9B,OAAOvK,KAAKgK,OAAOL,GAAK5B,WAGhC,MAAM,IAAI3C,EAAmB,iGAIdiF,GACf,GAAGA,KAASrK,KAAKgK,OACb,OAAOhK,KAAKgK,OAAOK,GAAOtC,WAG9B,MAAM,IAAI3C,EAAmB,qGAM7B,IAAMoF,EAAiB,GACvB,IAAI,IAAMpM,KAAO4B,KAAKgK,OAAQ,CAC1B,IAAMlE,EAAI9F,KAAKgK,OAAO5L,GAClB0H,EAAE2E,YAAYD,EAAe/D,KAAKX,GAE1C,OAAO0E,uCAQP,IAAI,IAAMb,KAAO3J,KAAKgK,OAClB,GAAmC,OAAhChK,KAAKgK,OAAOL,GAAK5B,WAAqB,OAAO,EAEpD,OAAO,4CAIP,IAAI2C,EAAW,GACf,IAAI,IAAMf,KAAO3J,KAAKgK,OAClBU,GAAY1K,KAAKgK,OAAOL,GAAKvM,KAAO,MAAQ4C,KAAKgK,OAAOL,GAAK7L,MAAQ,KAGzE,OADA4M,GAAY,2qBC5EpB,IAAI7H,EAAS3C,eACb2C,EAAOd,SAASc,EAAOtB,OAAOG,UAwBfiJ,cAVX,SAAAA,EAAY/D,GAAY,IAAAgE,EAEpB,+FAFoBC,CAAA7K,KAAA2K,GACpBC,EAAAE,EAAA9K,KAAA+K,EAAAJ,GAAA3N,KAAAgD,KAAM4G,EAAWE,gBACbF,EAAW8B,aACX,MAAM,IAAIpD,EAAqB,wFAHf,OAAAsF,8OAFLf,slCCEvB,IAAMhH,EAAS3C,YAAc,gBAC7B2C,EAAOd,SAASc,EAAOtB,OAAOG,UA4HfsJ,cAhHX,SAAAA,IAAuB,IAAAC,EAAAL,+FAAAM,CAAAlL,KAAAgL,GAAA,QAAAG,EAAAxL,UAAAI,OAARqL,EAAQ,IAAAxG,MAAAuG,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAARD,EAAQC,GAAA1L,UAAA0L,GAAA,OACnBT,EAAAU,EAAAtL,MAAAiL,EAAAM,EAAAP,IAAAhO,KAAA0C,MAAAuL,EAAA,CAAAjL,MAAAwL,OAASJ,KACTvI,EAAO1C,MAAM,8CAFMyK,wPAVMrF,yCA0B2B,IAAlDmB,EAAkD/G,UAAAI,OAAA,QAAAf,IAAAW,UAAA,GAAAA,UAAA,GAA9B,KAAMgH,IAAwBhH,UAAAI,OAAA,QAAAf,IAAAW,UAAA,KAAAA,UAAA,GACpD8L,EAAAF,EAAAP,EAAAvM,WAAA,QAAAuB,MAAAhD,KAAAgD,KAAY0G,EAAmBC,GACN,OAAtBD,IAECA,EAAoBmD,EAAW6B,gBAAgB1L,KAAK2F,aAExD9C,EAAO1C,MAAM,kDACTuG,EAAkBiF,mBACtB3L,KAAK4L,UAAY,EACjB,IAAMC,EAAS7L,KAAK8L,eAAepF,GAKnC,SAASqF,EAAS3N,EAAKN,GACnB,MAAY,WAARM,OAAkB,EACL,OAARA,OAAc,EACXN,EAPhB+E,EAAO1C,MAAM,WAAa8F,KAAKC,UAAU2F,IAUzChJ,EAAO1C,MAAM,kBApBuC,IAAA8G,GAAA,EAAAC,GAAA,EAAAC,OAAAnI,EAAA,IAqBpD,QAAAoI,EAAAC,EAAsBrH,KAAK6F,WAA3BjI,OAAA0J,cAAAL,GAAAG,EAAAC,EAAAE,QAAAC,MAAAP,GAAA,EAAuC,KAA7B+E,EAA6B5E,EAAAtJ,MACnC+E,EAAO1C,MAAM8F,KAAKC,UAAU8F,EAAUD,GAAY,MAtBF,MAAAtE,GAAAP,GAAA,EAAAC,EAAAM,EAAA,YAAAR,GAAA,MAAAI,EAAA,QAAAA,EAAA,oBAAAH,EAAA,MAAAC,GA0BpD,OAFAtE,EAAO1C,MAAM,MAEN0L,yCAGIjF,GAGX,GAFA5G,KAAK4L,YACL/I,EAAO1C,MAAM,kBAAoBH,KAAK4L,WACnChF,EAAW8B,aAAc,OAAO,IAAIiC,EAAS/D,GAChD,IAAMd,EAAI9F,KAAKiM,iBAAiBrF,GAG1BsF,EAAYpG,EAAEmD,YACdkD,EAAgBnM,KAAKoM,kBAAkBF,GARtBxE,GAAA,EAAAC,GAAA,EAAAC,OAAA5I,EAAA,IASvB,QAAA6I,EAAAC,EAAkBqE,EAAlBvO,OAAA0J,cAAAI,GAAAG,EAAAC,EAAAP,QAAAC,MAAAE,GAAA,EAAiC,KAAvB2E,EAAuBxE,EAAA/J,MAG7B,GAFAgI,EAAEwE,SAAS+B,GACXxJ,EAAO1C,MAAM,kBAAoByG,EAAW+E,mBACzC3L,KAAK2I,aAAa/B,GAAa,CAC9B,IAAMiF,EAAS7L,KAAK8L,eAAelF,GAOnC,GAAc,OAAXiF,EAAiB,OAAO,KAI3B,GAHA7L,KAAK4L,YACL/I,EAAO1C,MAAM,kBAAoBH,KAAK4L,WACtC/I,EAAO1C,MAAM,sBAAwB0L,EAAOpG,YAAYrI,MACrD4C,KAAKsM,WAAWT,KACfhJ,EAAOkE,MAAM,qBAAuB8E,EAAOF,mBAC3C3L,KAAK6F,WAAWY,KAAK,IAAIkE,EAASkB,KAC9B7L,KAAK2G,iBACL,OAAO,KAGfb,EAAEwE,SAAS,WAGXxE,EAAEwE,SAAS,OAlCI,MAAA7C,GAAAE,GAAA,EAAAC,EAAAH,EAAA,YAAAC,GAAA,MAAAI,EAAA,QAAAA,EAAA,oBAAAH,EAAA,MAAAC,GAqCvB,OAAOhB,2CASMA,GACb,IAAM2F,EAAiB3F,EAAW4F,yBAIlC,OADID,EAAe1H,KAAK4H,MAAM5H,KAAKC,SAAWyH,EAAexM,mDAW/C2M,GACd,OAAOA,uCC3If/P,EAAAQ,EAAAwP,EAAA,8BAAAC,IAAAjQ,EAAAQ,EAAAwP,EAAA,6BAAAE,IAAAlQ,EAAAQ,EAAAwP,EAAA,+BAAAG,IAAAnQ,EAAAQ,EAAAwP,EAAA,uCAAAI,IAAApQ,EAAAQ,EAAAwP,EAAA,+BAAAK,IAAArQ,EAAAQ,EAAAwP,EAAA,6BAAAM,IAAAtQ,EAAAQ,EAAAwP,EAAA,yCAAAtH","file":"consat.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"consat\"] = factory();\n\telse\n\t\troot[\"consat\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","/**\n * Custom exceptions for use in the CSPSolver.\n */\n\nclass CSPSolverValueError extends Error { };\n\nclass VariableValueError extends Error { };\n\nclass InvalidVariableError extends Error { };\n\nclass InvalidSolutionError extends Error { };\n\nclass NotImplementedError extends Error { };\n\nexport { CSPSolverValueError, VariableValueError, InvalidVariableError,\n    InvalidSolutionError, NotImplementedError };\n","/**\n * This is the base (abstract) CSPSolver class for the consat.js constraint\n * satisfaction solver library.\n *\n * This library provides support for solving constraint satisfaction problems\n * either by formulating the problem programmatically or by loading in a\n * problem description in XML format that can be used to define the problem.\n *\n * At present, this module provides a basic backtracking solver for discrete\n * variables with finite domains.\n */\nimport { InvalidVariableError } from './exceptions';\nimport * as log from 'loglevel';\n\nconst logger = log.noConflict();\nlogger.setLevel(logger.levels.INFO);\n\nclass CSPSolver {\n\n    /**\n     * This is an \"abstract\" class in that clients should instantiate a\n     * specific solver implementation and this class contains only common\n     * top-level implementation for CSP solvers. new.target is therefore used\n     * to check if an attempt is made to instantiate this class directly.\n     */\n    constructor() {\n        logger.debug('Constructor name: ' + this.constructor);\n        if(this.constructor === CSPSolver) {\n            throw TypeError('CSPSolver is an abstract class and can\\'t be ' +\n                    'instantiated directly.');\n        }\n\n        logger.debug('Initialising CSPSolver object...');\n        this._constraints = [];\n        this._variables = {};\n        this.varConstraintMap = {};\n        this._solutions = [];\n    }\n\n    addVariable(v) {\n        logger.debug('Adding variable named [' + v.getName() + '] with ID [' +\n                v.getId() + '] to var list');\n        logger.debug('Variables list: ' + JSON.stringify(this._variables));\n        // Check of this variable has already been added\n        if(v.getId() in this._variables) return false;\n        this._variables[v.getId()] = v;\n        return true;\n    }\n\n    addConstraint(c) {\n        logger.debug('Adding constraint between variable [' + c.getV2Name() +\n                '] and variable [' + c.getV1Name() + '] to constraint list.');\n        // Add the two variables to the list of variables for this constraint\n        // if they are not already present.\n        if(!(c.getV1Name() in this._variables)) {\n            this._variables[c.getV1Name()] = c.getV1();\n        }\n        if(!(c.getV2Name() in this._variables)) {\n            this._variables[c.getV2Name()] = c.getV2();\n        }\n\n        // Add entry to the varConstraintsMap for the variables that this\n        // constraint is involved with.\n        if(!(c.getV1Id() in this.varConstraintMap)) {\n            this.varConstraintMap[c.getV1Id()] = [];\n        }\n        if(!(c.getV2Id() in this.varConstraintMap)) {\n            this.varConstraintMap[c.getV2Id()] = [];\n        }\n        this.varConstraintMap[c.getV1Id()].push(c);\n        this.varConstraintMap[c.getV2Id()].push(c);\n\n        return true;\n    }\n\n    /**\n     * The solve function is not implemented here - an implementation of\n     * solve must be provided in subclasses of this CSPSolver class\n     */\n    solve(initialAssignment = null, getAllSolutions = true) {\n        this.getAllSolutions = getAllSolutions;\n        this.initialAssignment = initialAssignment;\n        this._solutions = [];\n    }\n\n    /**\n     * Check if the provided assignment - an instance of the Assignment class\n     * is consistent - that is, it does not violate any constraints. Note\n     * that this does not mean that the assignment is complete, some\n     * variables may still be unassigned.\n     */\n    isConsistent(assignment) {\n        // Check through each of the constraints to see if we have variables.\n        const varList = assignment.getVarList();\n        logger.trace('Value of varlist is: ' + JSON.stringify(varList));\n        const assignedVarMap = {};\n        for(const v of varList) {\n            // If the variable provided is not in our list of variables for\n            // this solve, then we throw an error.\n            logger.trace('Checking for existence of variable <' + v.getId() +\n                '> with name <' + v.getName() + '>');\n            if(!(v.getId() in this._variables)) {\n                throw new InvalidVariableError('Variable found in the ' +\n                    'assigned variables with ID [' + v.getId() + '] and ' +\n                    'name [' + v.getName() + '] is not registered for ' +\n                    'this solver instance.');\n            }\n            assignedVarMap[v.getId()] = v;\n        }\n        for(const v of varList) {\n            // If this variable is not present in any constraints then we\n            // can ignore it and continue with the next variable. We can also\n            // ignore the variable if it is unset (i.e. value is null)\n            logger.debug('Value of v is: ' + v.getValue());\n            if((!(v.getId() in this.varConstraintMap)) ||\n                    v.getValue() === null) continue;\n\n            // For a variable that exists in the constraint map, we need to\n            // check whether the variable's value is consistent with that of\n            // corresponding values of any variables in related constraints\n            const relatedConstraints = this.varConstraintMap[v.getId()];\n            for(const relConst of relatedConstraints) {\n                let otherVar = null;\n                if(relConst.getV1Id() === v.getId()) {\n                    otherVar = relConst.getV2();\n                }\n                else {\n                    otherVar = relConst.getV1();\n                }\n\n                // Now we need to check if the value of \"otherVar\" is in the\n                // list of target values for v. We need to find otherVar in\n                // the assignment since the instance of the variable with the\n                // value is in the assignment list.\n                const targetVarValue = assignment.getValueForVarById(otherVar.getId());\n                if(targetVarValue === null) {\n                    logger.debug('Target var value is null, don\\'t need ' +\n                            'check if the value is consistent.');\n                    continue;\n                }\n                const tgt = relConst.getTargetValues(v.getId(), v.getValue());\n                if(!(tgt.indexOf(assignment.getValueForVarById(otherVar.getId())) >= 0)) {\n                    logger.debug('The value of the corresponding ' +\n                            'variable in this constraint is not valid.');\n                    logger.debug('Variable value is <',\n                        assignment.getValueForVarById(otherVar.getId()),\n                        '>, source var is <', v.getId(), ', ',\n                        v.getValue(), '>, target values are ',\n                        relConst.getTargetValues(v.getId(), v.getValue()));\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Check if the provided assignment is a solution. An assignment that is\n     * a solution is one that is complete (i.e. all variables have values)\n     * and where all constraints are satisfied.\n     */\n    isSolution(assignment) {\n        return assignment.isComplete() && this.isConsistent(assignment);\n    }\n\n}\n\nexport default CSPSolver;\n","/**\n * A variable class representing a discrete variable with a finite domain of\n * values.\n *\n * The variable has a name, a domain and an optional value.\n */\nimport uuid from 'uuid/v1.js';\nimport * as log from 'loglevel';\nimport { VariableValueError } from './exceptions';\n\nconst logger = log.noConflict();\nlogger.setLevel(logger.levels.DEBUG);\n\nclass Variable {\n\n    constructor(name, domain, value = null, id = null) {\n        if(name === undefined || domain === undefined) {\n            throw new TypeError('Name and domain are required parameters.');\n        }\n        if(name === '') throw new TypeError('Name cannot be an empty string.');\n        if(domain.constructor !== Array) {\n            throw new TypeError('Domain must be an array of possible values.');\n        }\n        if(domain.length === 0) {\n            throw new TypeError('Domain array cannot be empty.');\n        }\n\n        // If a value is provided, it must be in the domain!\n        if(value !== null) {\n            if(domain.indexOf(value) === -1) {\n                throw new VariableValueError('The specified value is not ' +\n                        'in the provided domain of values.');\n            }\n        }\n\n        // Assign the variable a unique ID\n        if(id === null) this.id = uuid();\n        else this.id = id;\n\n        this.name = name;\n        this.domain = domain;\n        this.value = value;\n    }\n\n    getId() {\n        return this.id;\n    }\n\n    getName() {\n        return this.name;\n    }\n\n    getDomain() {\n        return this.domain;\n    }\n\n    getValue() {\n        return this.value;\n    }\n\n    hasValue() {\n        return this.value !== null;\n    }\n\n    setValue(value) {\n        if(!(this.domain.includes(value) || value === null)) {\n            throw new VariableValueError('The value specified for variable' +\n                    ' [' + this.id + '] is not in the value domain.');\n        }\n        else {\n            this.value = value;\n        }\n    }\n\n    valueInDomain(value) {\n        return this.domain.includes(value);\n    }\n\n    /**\n     * Create a new Variable object from an existing one\n     */\n    static fromVariable(v) {\n        return new Variable(v.getName(), v.getDomain(), v.getValue(),\n            v.getId());\n    }\n\n}\n\nexport default Variable;\n","/**\n * A constraint class representing a constraint between two variables.\n * The constraint is set up as a mapping between two variables, v1 and v2\n *\n * Since a constraint works in two directions, we need a two-way\n * representation of our constraint mapping. The client creating the instance\n * of this class only needs to specify the mapping in one direction and we\n * then generate the mapping in the other direction based on the information\n * from the provided mapping.\n *\n * Mappings are represented as an associative array with the value of the\n * source variable as the key and then a list of valid values of the target\n * variable as the value.\n */\nimport { VariableValueError, InvalidVariableError } from './exceptions';\nimport * as log from 'loglevel';\n\nconst logger = log.noConflict();\nlogger.setLevel(logger.levels.INFO);\n\nclass Constraint {\n\n    constructor(v1, v2, mappingsV1toV2) {\n        if(v1.getName() === v2.getName()) {\n            throw new VariableValueError('The two variables for this ' +\n                    'constraint cannot have the same name.');\n        }\n\n        const mappingsV2toV1 = {};\n        // Begin by setting up reverse mappings from v2 to v1\n        // We go through the mappings and check for each item that the source\n        // and all the target values appear in the domains of the relevant\n        // variables. If they don't then the provided mapping is incorrect.\n        for(let key in mappingsV1toV2) {\n            if(!v1.valueInDomain(key)) {\n                log.error('The provided variable mapping is invalid.' +\n                        'Value [' + key + '] is specified as a mapping key' +\n                        ' is not a in the value domain for variable 1 [' +\n                        v1.getName() + ']');\n                throw new VariableValueError('Value [' + key + '] is ' +\n                        'specified as a mapping key is not a in the value ' +\n                        'domain for variable 1 [' + v1.getName() + ']');\n            }\n            // Add the current value (key) to the V2toV1 table...\n            for(let val of mappingsV1toV2[key]) {\n                if(!(val in mappingsV2toV1)) {\n                    mappingsV2toV1[val] = [];\n                }\n                mappingsV2toV1[val].push(key);\n            }\n        }\n\n        // Store class variables\n        this.v1 = v1;\n        this.v2 = v2;\n        this.mappingsV1toV2 = mappingsV1toV2;\n        this.mappingsV2toV1 = mappingsV2toV1;\n    }\n\n    getV1() {\n        return this.v1;\n    }\n\n    getV1Name() {\n        return this.v1.getName();\n    }\n\n    getV1Id() {\n        return this.v1.getId();\n    }\n\n    getV2() {\n        return this.v2;\n    }\n\n    getV2Name() {\n        return this.v2.getName();\n    }\n\n    getV2Id() {\n        return this.v2.getId();\n    }\n\n    /**\n     * Get all the target values for the specified variable and value.\n     */\n    getTargetValues(vId, vValue) {\n        // Check whether we've been passed a value for var1 or var2 and then\n        // get the corresponding values from the relevant mapping\n        logger.trace('Getting target values for vId <', vId, '> with value <',\n            vValue, '>.');\n        if(vId === this.v1.getId()) {\n            if(!(vValue in this.mappingsV1toV2)) {\n                logger.debug('The specified value <' + vValue + '> is not ' +\n                    'a valid value for the variable with ID <' + vId + '>. ' +\n                    'Mappings are ' + JSON.stringify(this.mappingsV1toV2));\n                throw new VariableValueError('The specified value is not ' +\n                'a valid value for the variable named.');\n            }\n            return this.mappingsV1toV2[vValue];\n        }\n        else if(vId === this.v2.getId()) {\n            if(!(vValue in this.mappingsV2toV1)) {\n                logger.trace('The specified value <' + vValue + '> is not ' +\n                        'a valid value for the variable with ID <' + vId + '>. ' +\n                        'Mappings are ' + JSON.stringify(this.mappingsV2toV1));\n                throw new VariableValueError('The specified value is not ' +\n                        'a valid value for the variable named.');\n            }\n            return this.mappingsV2toV1[vValue];\n        }\n        else {\n            throw new InvalidVariableError('Invalid variable name provided.');\n        }\n    }\n\n}\n\nexport default Constraint;\n","/**\n * The assignment class provides one instance of an \"assignment\" - a list of\n * all the variables in a CSP with some or all of them assigned a value.\n */\nimport { VariableValueError } from './exceptions.js';\nimport Variable from './variable.js';\nimport * as log from 'loglevel';\n\nvar logger = log.noConflict();\nlogger.setLevel(logger.levels.INFO);\n\nclass Assignment {\n\n    constructor(assignedVariableList) {\n        const varMap = {};\n        for(const v of assignedVariableList) {\n            logger.debug('Creating variable...');\n            logger.debug('Var name: ' + v.getName());\n            logger.debug('Var ID: ' + v.getId());\n            logger.debug('Var value: ' + v.getValue());\n            logger.debug('Var domain: ' + JSON.stringify(v.getDomain()));\n            const newVar = Variable.fromVariable(v);\n            varMap[newVar.getId()] = newVar;\n        }\n        this.varMap = varMap;\n    }\n\n    getVarList() {\n        const varList = [];\n        for(const key in this.varMap) {\n            varList.push(this.varMap[key]);\n        }\n        return varList;\n    }\n\n    getValueForVarByName(varName) {\n        for(const vId in this.varMap) {\n            if(this.varMap[vId].getName() === varName) {\n                return this.varMap[vId].getValue();\n            }\n        }\n        throw new VariableValueError('A variable with the specified ' +\n                'name does not exist.');\n    }\n\n    getValueForVarById(varId) {\n        if(varId in this.varMap) {\n            return this.varMap[varId].getValue();\n        }\n        // If the variable ID isn't in the map, throw an error.\n        throw new VariableValueError('A variable with the specified ' +\n                'ID does not exist.');\n    }\n\n    // Get the list of unassigned variables for this assignment\n    getUnassignedVariables() {\n        const unassignedVars = [];\n        for(const key in this.varMap) {\n            const v = this.varMap[key];\n            if(!v.hasValue()) unassignedVars.push(v);\n        }\n        return unassignedVars;\n    }\n\n    /**\n     * Check if this assignment is complete. An assignment that is\n     * complete is one where all the variables in the assignment have values.\n     */\n    isComplete() {\n        for(const vId in this.varMap) {\n            if(this.varMap[vId].getValue() === null) return false;\n        }\n        return true;\n    }\n\n    printAssignment() {\n        let printStr = '';\n        for(const vId in this.varMap) {\n            printStr += this.varMap[vId].name + ' = ' + this.varMap[vId].value + '\\t';\n        }\n        printStr += '\\n';\n        return printStr;\n    }\n\n    static emptyAssignment(variableMap) {\n        const assignmentList = [];\n        for(const varId in variableMap) {\n            const newVar = Variable.fromVariable(variableMap[varId]);\n            newVar.setValue(null);\n            assignmentList.push(newVar);\n        }\n        return new Assignment(assignmentList);\n    }\n\n}\n\nexport default Assignment;\n","import * as log from 'loglevel';\nimport Assignment from './assignment.js';\nimport { InvalidSolutionError } from './exceptions.js';\n\nvar logger = log.noConflict();\nlogger.setLevel(logger.levels.INFO);\n\n/**\n * A solution is an assignment for which all variables have values and all\n * these values are consistent with the set of constraints for the given CSP.\n *\n * At present we don't check for consistency when creating a solution - this\n * is done by the target CSP solver class since this has access to the\n * variable and constraint details to make such checks. It is therefore\n * assumed that the provided solution is consistent and this is simply a\n * marker subclass to identify a given assignment as a solution.\n */\nclass Solution extends Assignment {\n\n    constructor(assignment) {\n        super(assignment.getVarList());\n        if(!assignment.isComplete()) {\n            throw new InvalidSolutionError('The provided assignment is ' +\n                'incomplete. Can\\'t create a solution from this assignment.');\n        }\n    }\n\n}\n\nexport default Solution;\n","/**\n * Implementation of a simple backtracking CSP solver. Extends the\n * main CSPSolver class defined in index.js.\n *\n * This solver uses a recursive approach to identify possible solutions given\n * a CSP definition. For a given problem definition and assignment, the\n * solver checks if the assignment is complete and if not:\n * Recursive stage: it selects one of the unassigned variables in the\n * assignment. It then checks if the new set of assignments is consistent.\n * If so it recurses to the next level of the tree, returning to the\n * \"Recursive stage\" marker. If the assignment is not consistent, this branch\n * of the tree fails and we jump back to the previous state and try another\n * branch.\n */\nimport CSPSolver from './cspsolver';\nimport Assignment from './assignment';\nimport Solution from './solution';\nimport * as log from 'loglevel';\n\nconst logger = log.getLogger('backtracking');\nlogger.setLevel(logger.levels.INFO);\n\nclass BacktrackingSolver extends CSPSolver {\n\n    // Variables and constraints set via superclass, this just provides an\n    // implementation of solve using the backtracking method.\n    // Superclass provides:\n    // this._constraints = [];\n    // this._variables = {}; - a map of variable ID to object\n    // this.varConstraintMap = {}; - a map of variable ID to an array of\n    //                               constraints with which that variable\n    //                               is involved.\n    constructor(...params) {\n        super(...params);\n        logger.debug('Creating a backtracking solver instance...');\n    }\n\n    /**\n     * The solve function is the entry point to the recursive solve process.\n     * When calling the solve here we identify whether we want only the first\n     * solution or a list of all solutions.\n     *\n     * initialAssignent: an assignment object containing the initial state\n     * getAllSolutions: true: get all solutions, false: return first solution\n     *\n     * If you want to get only the first solution for an unassigned initial\n     * state, call solve with (null, false)\n     */\n    solve(initialAssignment = null, getAllSolutions = true) {\n        super.solve(initialAssignment, getAllSolutions);\n        if(initialAssignment === null) {\n            // Prepare a blank initial assignment\n            initialAssignment = Assignment.emptyAssignment(this._variables);\n        }\n        logger.debug('About to start solve with initial assignment:\\n' +\n            initialAssignment.printAssignment());\n        this.treeLevel = 0;\n        const result = this.recursiveSolve(initialAssignment);\n        logger.debug('Result: ' + JSON.stringify(result));\n\n        // Format the output data as JSON that we can load in as an object\n        // later in order to test the solver output.\n        function replacer(key, value) {\n            if (key === 'domain') return undefined;\n            else if (key === 'id') return undefined;\n            else return value;\n        }\n\n        logger.debug('{\"solutions\":[');\n        for(const solution of this._solutions) {\n            logger.debug(JSON.stringify(solution, replacer) + ',');\n        }\n        logger.debug(']}');\n\n        return result;\n    }\n\n    recursiveSolve(assignment) {\n        this.treeLevel++;\n        logger.debug('AT TREE LEVEL: ' + this.treeLevel);\n        if(assignment.isComplete()) return new Solution(assignment);\n        const v = this.getUnassignedVar(assignment);\n        // We now process the selected unassigned variable working through\n        // each of its values in turn each time we return to this tree node\n        const varDomain = v.getDomain();\n        const updatedDomain = this.orderDomainValues(varDomain);\n        for(const item of updatedDomain) {\n            v.setValue(item);\n            logger.debug('Assignment is: ' + assignment.printAssignment());\n            if(this.isConsistent(assignment)) {\n                const result = this.recursiveSolve(assignment);\n                // If we're only getting a single result then we receive null here\n                // so send null back to exit from the recursion stack\n                // FIXME: The return is inconsistent here, if we're getting all solutions\n                // then an assignment is returned, if only a single solution has been requested\n                // then we return for now. This satisfies the tests and is ok for now but may\n                // cause issues with different intended uses of the API so needs resolving.\n                if(result === null) return null;\n                this.treeLevel--;\n                logger.debug('AT TREE LEVEL: ' + this.treeLevel);\n                logger.debug('TYPE OF RESULT IS: ' + result.constructor.name);\n                if(this.isSolution(result)) {\n                    logger.trace('RESULT TO RETURN: ' + result.printAssignment());\n                    this._solutions.push(new Solution(result));\n                    if(!this.getAllSolutions) {\n                        return null;\n                    }\n                }\n                v.setValue(null);\n            }\n            else {\n                v.setValue(null);\n            }\n        }\n        return assignment;\n    }\n\n    /**\n     * Select an unassigned variable from the assignment. To this, we get all\n     * the unassigned vars from the assignment and then pick one at random.\n     * This function can be updated to add heuristics to improve the variable\n     * selection in a way that will increase the solver performance.\n     */\n    getUnassignedVar(assignment) {\n        const unassignedList = assignment.getUnassignedVariables();\n        // Get a random item from the list\n        const randVar =\n            unassignedList[Math.floor(Math.random() * unassignedList.length)];\n        return randVar;\n    }\n\n    /**\n     * Order the list of domain values. This process can be used to implement\n     * heuristics that improve solver performance.\n     *\n     * NOTE: For now, this is a placeholder that simply returns the values\n     * given in the order they were provided.\n     */\n    orderDomainValues(values) {\n        return values;\n    }\n\n}\n\nexport default BacktrackingSolver;\n","/**\n * Entry point for the consat.js Constraint Satisfaction Solver library.\n *\n * This library provides support for solving constraint satisfaction problems\n * either by formulating the problem programmatically or by loading in a\n * problem description in XML format that can be used to define the problem.\n *\n * At present, this module provides a basic backtracking solver for discrete\n * variables with finite domains.\n */\nimport CSPSolver from './cspsolver';\nimport Variable from './variable';\nimport Constraint from './constraint';\nimport Assignment from './assignment';\nimport Solution from './solution';\nimport BacktrackingSolver from './backtrackingsolver';\nimport { InvalidVariableError } from './exceptions';\n\nexport { CSPSolver, Variable, Constraint, BacktrackingSolver, Assignment,\n    Solution, InvalidVariableError };\n"],"sourceRoot":""}